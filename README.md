The 24-Puzzle Game is a console-based tile puzzle implemented in C++ that simulates a 5x5 sliding puzzle. It challenges the player to transform an initial board state into a predefined goal state using legal tile movements. The board consists of tiles numbered from 1 to 24 and one blank space. A tile adjacent to the blank can be slid into that space, allowing the player to rearrange the board. The game ensures both the initial and goal states are randomly generated yet solvable, applying inversion logic to verify validity.

At the start of the game, the init() function generates a randomized initial state by shuffling tile values on a 5x5 grid. Simultaneously, the goal() function sets up a goal state that is guaranteed to be reachable from the initial one. This solvability is ensured by the Is_Solveable() function, which checks the number of inversions present in the board. Inversions are counted based on the row-major order of the puzzle. For odd-sized boards like this one, a board is solvable only if it has an even number of inversions. This prevents players from wasting time trying to solve an impossible configuration.

As the game progresses, the program identifies valid tile movements using the legal_moves() function. This determines which directions—up, down, left, or right—the blank tile can move without going out of bounds. The player can then input a move, and the make_move() function applies that move by swapping the blank with the corresponding adjacent tile. After each move, the game checks whether the player has reached the goal using the is_goal() function. If the current board matches the goal configuration, the puzzle is considered solved.

Throughout gameplay, the system records every move made by the user. These moves are saved using standard file handling in C++, allowing the entire sequence to be logged into an external file for analysis or replay. Once the goal is achieved, the print_path() function displays the full list of moves taken to solve the puzzle in order. This allows players to reflect on their strategy or improve their approach in future runs.

The entire program is built with a modular and function-based design in mind, emphasizing clarity and reusability. It makes strong use of core C++ concepts such as 2D arrays, pointer manipulation, dynamic memory, condition checking, and file streams for input/output operations. The game runs in a standard console environment and does not rely on any external libraries, making it portable and easy to compile on any C++ compiler that supports basic I/O.

This project not only provides a playable sliding puzzle game but also serves as a hands-on demonstration of logical thinking, board manipulation, and algorithmic problem-solving using C++.

